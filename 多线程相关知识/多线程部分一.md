#### 多线程部分一

# 1. 什么是进程、线程

进程是正在运行的程序实例。进程是线程的容器，即一个进程中可以开启多个线程。

线程是进程内部的一个独立执行单元，一个进程可以同时并发运行多个线程。

# 2. 线程创建

Java中线程有四种创建方式

* 继承Thread 类
* 实现Runnable 接口
* 实现Callable 接口
* 线程池

# 3. 需要补充

## 3.1 Callable 接口

Callable需要使用 FutureTask 类帮助执行， FutureTask 类结构如下：

![image-20200412093424618](I:\GreatGeek\CollectKnowledge\多线程相关知识\多线程部分一.assets\image-20200412093424618.png)

因为FutureTask 间接实现了Runnable 接口，所以Thread 可以对FutureTask 进行静态代理，即 ```new Thread(task).start;```。

## 3.2 线程池-Executor

线程池类关系图：

![image-20200412093756809](I:\GreatGeek\CollectKnowledge\多线程相关知识\多线程部分一.assets\image-20200412093756809.png)

# 4. 小结

## 4.1 实现接口和继承Thread 类比较

* 接口更适合多个相同的程序代码的线程去共享同一个资源；
* 接口可以避免Java 中单继承的局限性；
* 接口代码可以被多个线程共享，代码和线程独立；
* 线程池只能放入实现Runnable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。

补充：

在Java 中，每次程序运行至少启动2个线程。一个是 main 线程，一个是垃圾收集线程。

## 4.2 Runnable 和 Callable接口比较

相同点：

* 两者都是接口；
* 两者都可用来编写多线程程序；
* 两者都需要调用 Thread.start() 启动线程；

不同点：

* 实现Callable 接口的线程能返回执行结果；而实现Runnable 接口的线程不能返回结果；
* Callable接口的call() 方法允许抛出异常；而Runnable 接口的run() 方法不允许抛出异常；
* 实现Callable 接口的线程可以调用 Future.cancel 取消执行，而实现 Runnable 接口的线程不能。

注意点：

* Callable 接口支持返回执行结果，此时需要调用 FutureTask.get() 方法实现，此方法会阻塞主线程直到获取 “将来”结果；当不调用此方法时，主线程不会阻塞。

#### 5. 线程的生命周期

![image-20200412094653647](I:\GreatGeek\CollectKnowledge\多线程相关知识\多线程部分一.assets\image-20200412094653647.png)

1. 新建

   * new 关键字创建了一个线程之后，该线程就处于新建状态；
   * JVM 为线程分配内存，初始化成员变量值；

2. 就绪

   * 当线程对象调用了start() 方法之后，该线程处于就绪状态；
   * JVM 为线程创建方法栈和程序计数器，等待线程调度器调度；

3. 运行

   * 就绪状态的线程获得CPU资源，开始运行run() 方法，该线程进入运行状态；

4. 阻塞

   当发生如下情况时，线程将会进入阻塞状态：

   * 线程调用 sleep() 方法主动放弃所占用的处理器资源；
   * 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
   * 线程试图获得一个同步锁（同步监视器），但该同步锁正被其他线程所持有；
   * 线程在等待某个通知（notify）
   * 程序调用了线程的suspend() 方法将该线程挂起。但这个方法容易导致死锁，应该尽量避免使用该方法

5. 死亡

   线程会以如下3种方法结束，结束后就处于死亡状态：

   * run() 或 call() 方法执行完成，线程正常结束；
   * 线程抛出一个未捕获的 Exception 或 Error；
   * 调用该线程 stop() 方法结束该线程，该方法容易导致死锁，不推荐使用。

# 6. 线程安全问题

为了保证每个线程都能正常执行共享资源操作，Java 引入了7种线程同步机制。

1. 同步代码块（synchronized）

   ```java
   synchronized(同步锁){
       //需要同步操作的代码
   }
   ```

   同步锁：

   对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。

   * 锁对象可以是任意类型；
   * 多个线程要使用同一把锁；

   注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就能进入代码块，其他线程只能在外面等着（BLOCKED）。

2. 同步方法（synchronized）

   ```java
   public synchronized void method(){
       //可能会产生线程安全问题的代码
   }
   ```

   * 对于非static 方法，同步锁就是this。
   * 对于static 方法，同步锁是当前方法所在类的字节码对象（类名.class）。

3. 同步锁（ReentrantLock）

   同步锁方法：

   ```java
   public void lock(); // 加同步锁
   public void unlock(); // 释放同步锁
   ```

   

4. 特殊域变量（volatile）

5. 局部变量（ThreadLocal）

6. 阻塞队列（LinkedBlockingQueue）

7. 原子变量（Atomic*）

小结：

synchronized 和 Lock 区别：

* synchronized是Java内置关键字，在JVM层面，Lock是个Java类；
* synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁；
* synchronized 会自动释放锁，Lock需要在 finally中手动释放锁。
* 用synchronized 关键字的两个线程1 和线程2，如果当前线程1获得锁，线程2会等待。如果线程1阻塞，线程2会一直等待下去，而Lock 锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就可以结束。
* synchronized 的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平也可不公平。
* Lock锁适合大量同步的代码的同步问题，synchronized 锁适合代码少量的同步问题。

# 7. 线程死锁

死锁产生的必要条件：

以下这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

1. 互斥条件

   进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

2. 不可剥夺条件

   进程获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程主动释放。

3. 请求与保持条件

   进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

4. 循环等待条件

   存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

## 7.1 死锁处理

* 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
* 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
* 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。
* 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。

## 7.2 死锁避免

### 7.2.1 有序资源分配法

该算法实现步骤如下：

* 必须为所有资源统一编号，例如打印机为1，传真机为2，磁盘为3等；
* 同类资源必须一次申请完，例如打印机和传真机一般为同一个机器，必须同时申请；
* 不同类资源必须按顺序申请；

### 7.2.2 银行家算法

![image-20200412200751646](I:\GreatGeek\CollectKnowledge\多线程相关知识\多线程部分一.assets\image-20200412200751646.png)

银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。

设进程i 提出请求 REQUEST[i] ，则银行家算法按如下规则进行判断：

1. 如果REQUEST[i] <= NEED[i,j]，则转（2）；否则出错；

2. 如果REQUEST[i]<=AVAILABLE[i]，则转（3）；否则，等待；

3. 系统试探分配资源，修改相关数据：

   ```java
   AVAILABLE[i] -= REQUEST[i];// 可用资源数 - 请求资源数
   ALLOCATION[i] += REQUEST[i]; // 已分配资源数 + 请求资源数
   NEED[i] -= REQUEST[i]; // 需要资源数 - 请求资源数
   ```

4. 系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。

### 7.2.3 顺序加锁

按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景。

### 7.2.4 限时加锁

限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退释放所有已经得到的锁，然后等待一段随机时间再重试。

这种方式有两个缺点：

1. 当线程数量少时，该咱方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。
2. Java 中不能对 synchronized 同步块设置超时时间。你需要创建一个自定义锁，或使用 Java5 中 java.util.concurrent包下的工具。

## 7.4 死锁检测

预防和避免死锁系统开销大且不能充分利用资源，更好的方法是不采取任何限制性措施，而是提供检测和解脱死锁的手段，这就是死锁检测和恢复。

死锁检测数据结构：

![image-20200412204231136](I:\GreatGeek\CollectKnowledge\多线程相关知识\多线程部分一.assets\image-20200412204231136.png)

死锁检测步骤：

1. 寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i 行向量小于或等于A；
2. 如果找到了这样一个进程，执行该进程，然后将C 矩阵的第i 行向量加到A 中，标记该进程，并转到第1 步；
3. 如果没有这样的进程，那么算法终止；
4. 算法结束时，所有没有标记过的进程都是死锁进程。

## 7.5 死锁恢复

* 利用抢占恢复

  临时将某个资源从它的当前所属进程转移到另一个进程。

  这种做法很可能需要人工干预，主要做法是否可行需要取决于资源本身的特性。

* 利用回滚恢复

  周期性的将进程状态进行备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没有取得所需要的资源的状态，接着就把这些资源分配给其他死锁进程。

* 通过杀死进程恢复

  最直接简单的方式就是杀死一个或若干个进程。

  尽可能保证杀死的进程可以从头再来而不带来副作用。

# 8. 为什么要线程通信

多个线程并发执行时，在默认情况下CPU是随机切换线程的，有时我们希望CPU按我们的规律执行线程，此时就需要线程之间协调通信。

## 8.1 线程通讯方式

线程间通信常用方式如下：

* 休眠唤醒方式：

  Object 的 wait、notify、notifyAll

  Condition 的 await, signal, signalAll

* CountDownLatch: 用于某个线程A等待若干个其他线程执行完之后，它才执行

* CyclicBarrier：一组线程等待至某个状态之后再全部同时执行

* Semaphore：用于控制对某组资源的访问权限

### 8.1.1 休眠唤醒方式

Object 和 Condition 休眠唤醒区别

* object wait() 必须在 synchronized （同步锁）下使用；
* object wait() 必须要通过 notify() 方法进行唤醒；
* condition await() 必须和Lock （互斥锁/共享锁）配合使用；
* condition await() 必须通过 signal() 方法进行唤醒；