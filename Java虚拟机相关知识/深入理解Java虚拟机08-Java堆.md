# Java 堆

Java 堆是垃圾收集器管理的内存区域。作为业界绝对主流的HotSpot 虚拟机，它内部的垃圾收集器全部都基于“经典分代” 来设计，需要新生代、老年代收集器搭配才能工作。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java 堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好的回收内存，或者更快地分配内存。

# 1. 对象的创建

当Java 虚拟机遇到一条字节码new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，对象分配空间的任务实际上便等于把一块确定大小的内存块从Java 堆中划分出来。

内存分配完成后，虚拟机必须将分配到的内存空间（对象头除外）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前到TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object:: hashCode() 方法时才计算）、对象的GC分代的年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

在上面工作都完成之后 ，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>() 方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new 指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new 关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new 指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

# 2. 对象的内存布局

![image-20200416115010432](I:\GreatGeek\CollectKnowledge\Java虚拟机相关知识\深入理解Java虚拟机08-Java堆.assets\image-20200416115010432.png)

在HotSpot虚拟机里，对象在堆内存中了存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。

* 对象头包括两类信息：

  * 用于存储对象自身的运行时数据；
  * 类型指针；

* 实例数据部分是对象真正存储的有效信息；

* 对齐填充

  对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。

# 3. 对象的访问定位

![image-20200416115939069](I:\GreatGeek\CollectKnowledge\Java虚拟机相关知识\深入理解Java虚拟机08-Java堆.assets\image-20200416115939069.png)

在HotSpot中使用的是后者。